<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/shcema/beans/spring-beans.xsd"
        default-init-method="init"
        default-destroy-method="destroy">
    <!-- 为了与容器中bean生命周期的管理进行交互，你可以实现Spring的InitializingBean和DisposableBean接口。当初始化bean时
    容器会调用InitializingBean中的afterPropertiesSet方法，当销毁beans时容器会调用DisposableBean中的destroy方法，在这2个
    方法中bean可以执行特定的行为。
    在现在应用中，通常认为JSR-250的@PostConstruct和@PreDestroy注解是最佳实践接收生命周期的方法，使用这些注解意味你的bean
    没有耦合Spring特定的接口。除了初始化回调函数和销毁回调函数之外，Spring管理的对象也可以实现Lifecycle接口，这些对象可以
    参与容器自身生命周期驱动的启动和关闭过程。
    建议不使用InitializingBean接口，因为他对代码与Spring进行了不必要的耦合。作为一种替代方法，你可以使用@PostConstruct注解
    或制定一个POJO的初始化方法。在基于XML配置元数据的情况下，你可以使用init-method特性来指定方法的名称，方法时没有返回值
    和参数的。如果使用@Bean的initMethod特性，请看“接收生命周期回调函数”小节，以下代码和AnotherExampleBean是等价的-->
    <bean id="exampleInitBean" class="com.pansy.ExampleBean" init-method="init"/>
    <!-- 销毁回调函数也相同-->
    <bean id="exampleDestroyBean" class="com.pansy.ExampleBean2" destroy-method="cleanup"/>
    <!-- 默认初始化和销毁方法，在beans元素上添加default-init-method属性，假设你的初始化回调方法名为init，销毁回调方法
    名为destroy，你的类如DefaultBlogService-->
    <bean id="blogDao" class="com.pansy.BlogDao"/>
    <bean id="blogService" class="com.pansy.DefaultBlogService">
        <property name="blogDao" ref="blogDao"/>
    </bean>
    <!-- 在Spring2.5开始，在控制bean的生命周期行为时，有三种选择：InitializingBean和DisposableBean回调接口；定制init接口
    和destroy接口，@PostConstruct和@PreDestroy注解。在控制一个给定bean时你可以组合这些机制。
    同一个bean配置了多生命周期机制，并有不同的初始化方法时，那么调用顺序如下：
    先调用注解@PostConstruct
    然后调用InitializingBean回调接口定义的afterPropertiesSet方法
    最后调用定制配置的init方法
    销毁回调函数调用顺序相同
    -->
    <!-- 当ApplicationContext创建一个实现org.springframework.context.ApplicationContextAware接口的对象实例时，这个实例
    会提供一个ApplicationContext的引用，因此beans可以以编程的方式创建他们的ApplicationContext，通过ApplicationContext
    接口，或通过将引用抛给这个接口的一个已知子类，例如ConfigurableApplicationContext，它暴露了额外的功能。一个方法是编程
    式检索其他bean。有时这个能力是很有用的，但是通常你应该避免使用它，因为它耦合了Spring和代码，不能遵循控制反转的风格。
    ApplicationContext的其它方法提供了对文件资源的访问，发布应用事件，访问MessageSource的功能。这些额外的特性讲在3.15小节
    ApplicationContext的额外能力中讲述
    从Spring2.5开始，自动装配是另一种可替代的获得ApplicationContext引用的方法。传统的constructor和byType自动装配模式可以
    分别为构造器函数参数和setter方法参数提供ApplicationContext类型的依赖。更多的灵活性包括自动装配变量的能力和多参数方法
    使用新的基于注解的自动装配特性。如果你这么做的话，ApplicationContext可以被自动装配到变量中，构造函数参数中和方法参数
    中，如果讨论的变量，构造参数和方法有@Autowired注解，那么可以期待它是ApplicationContext类型。更多请看3.9.2小节
    当ApplicationContext创建了一个实现了org.springframework,beans.factory.BeanFactory.BeanNameAware接口的类时，类中有相关
    的对象定义中定义的名称的引用。在正常的bean属性填入之后，回调方法调用，但在初始化方法调用之前，例如InitializingBean的
    afterPropertiesSet或一个定制的初始化方法-->
</beans>